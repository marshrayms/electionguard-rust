// Copyright (C) Microsoft Corporation. All rights reserved.

//#![cfg_attr(rustfmt, rustfmt_skip)]
#![deny(clippy::expect_used)]
#![deny(clippy::manual_assert)]
#![deny(clippy::panic)]
#![deny(clippy::unwrap_used)]
#![allow(clippy::assertions_on_constants)]
#![allow(dead_code)] //? TODO: Remove temp development code
#![allow(unused_assignments)] //? TODO: Remove temp development code
#![allow(unused_braces)] //? TODO: Remove temp development code
#![allow(unused_imports)] //? TODO: Remove temp development code
#![allow(unused_mut)] //? TODO: Remove temp development code
#![allow(unused_variables)] //? TODO: Remove temp development code
#![allow(unreachable_code)] //? TODO: Remove temp development code
#![allow(non_camel_case_types)] //? TODO: Remove temp development code
#![allow(non_snake_case)] //? TODO: Remove temp development code
#![allow(noop_method_call)] //? TODO: Remove temp development code

use std::{
    borrow::BorrowMut,
    cell::{RefCell, RefMut},
    num::NonZeroUsize,
    ops::RangeInclusive,
};

use num_bigint::BigUint;
use rand::{
    distr::{Distribution, Uniform},
    RngCore,
};

use crate::csprng::Csprng;

//=================================================================================================|

/// Trait expressing operations provided by a CSRNG. Similar to the interface provided by
/// [`util::Csprng`], but since this interface is notionally stateless it requires
/// only a shared reference.
///
pub trait Csrng {
    /// Fills the supplied buffer with generated bytes.
    ///
    /// Compare to `rand::RngCore::fill_bytes`.
    fn fill_buf(&self, buf: &mut [u8]);

    /// Returns a uniformly random `bool`.
    fn next_bool(&self) -> bool;

    /// Returns a uniformly random `u8`.
    fn next_u8(&self) -> u8;

    /// Returns a uniformly random `u32`.
    fn next_u32(&self) -> u32;

    /// Returns a uniformly random `u64`.
    fn next_u64(&self) -> u64;

    /// Returns a uniformly random `u128`.
    fn next_u128(&self) -> u128;

    // Returns a random number chosen uniformly from 0 <= n < 2^bits.
    fn next_biguint(&self, bits: NonZeroUsize) -> BigUint;

    /// Returns a random number that requires exactly the specified number of bits to represent.
    /// If `bits == 1`, chosen uniformly `0` or `1`.
    /// else `bits > 1`, chosen uniformly from `2^(bits - 1) <= n < 2^bits`.
    /// I.e., the high bit position `bits - 1` is guaranteed to be set, but all lower
    /// bit positions are uniform random.
    fn next_biguint_requiring_bits(&self, bits: NonZeroUsize) -> BigUint;

    /// Returns a random number uniformly from `0 <= n < end`.
    /// `end` must be greater than `0`.
    fn next_biguint_lt(&self, end: &BigUint) -> Option<BigUint>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_biguint_range(&self, start: &BigUint, end: &BigUint) -> Option<BigUint>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_u32_range(&self, start: u32, end: u32) -> Option<u32>;

    /// Returns a random number uniformly from `start <= n <= end`.
    /// `start` must be less or equal to `end`.
    fn next_u32_rangeinclusive(&self, start: u32, end: u32) -> Option<u32>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_usize_range(&self, start: usize, end: usize) -> Option<usize>;

    /// Returns a random number uniformly from `start <= n <= end`.
    /// `start` must be less or equal to `end`.
    fn next_usize_rangeinclusive(&self, start: usize, end: usize) -> Option<usize>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_u64_range(&self, start: u64, end: u64) -> Option<u64>;

    /// Returns a random number uniformly from `start <= n <= end`.
    /// `start` must be less or equal to `end`.
    fn next_u64_rangeinclusive(&self, start: u64, end: u64) -> Option<u64>;
}

/// Operations provided by a CSRNG which can be implemented using the [`Csrng`] trait, but would
/// make it not object-safe.
///
pub trait CsrngOps {
    /// Returns an array of uniformly random `u8`s.
    fn next_arr_u8<const N: usize>(&self) -> [u8; N];
}

impl<T> CsrngOps for T
where
    T: Csrng + ?Sized,
{
    fn next_arr_u8<const N: usize>(&self) -> [u8; N] {
        let mut buf = [0_u8; N];
        self.fill_buf(&mut buf);
        buf
    }
}

//=================================================================================================|

/// Wraps a [`Csprng`] and uses interior mutability to provide a [`Csrng`] interface.
pub struct DeterministicCsrng(RefCell<Csprng>);

impl DeterministicCsrng {
    /// Creates a new [`DeterministicCsrng`] wrapping the provided [`Csprng`].
    #[inline]
    pub fn new(csprng: Csprng) -> DeterministicCsrng {
        Self(RefCell::new(csprng))
    }

    /// Creates a new [`DeterministicCsrng`] using a CSPRNG initialized from a string.
    ///
    #[inline]
    pub fn from_seed_str<AsRefStr>(seed_str: AsRefStr) -> Self
    where
        AsRefStr: AsRef<str>,
    {
        Self::new(Csprng::from_seed_str(seed_str))
    }

    /// Consumes the [`DeterministicCsrng`], returning the wrapped [`Csprng`].
    pub fn into_inner(self) -> Csprng {
        self.0.into_inner()
    }

    fn borrow_csprng(&self) -> RefMut<'_, Csprng> {
        // Unwrap() is justified here because DeterministicCsrng::0 could not have already been
        // borrowed as it is never visible outside of this struct, and none of the implementation
        // is re-entrant.
        #[allow(clippy::unwrap_used)]
        self.0.try_borrow_mut().unwrap()
    }
}

impl Csrng for DeterministicCsrng {
    fn fill_buf(&self, buf: &mut [u8]) {
        self.borrow_csprng().fill_buf(buf);
    }

    fn next_bool(&self) -> bool {
        self.borrow_csprng().next_bool()
    }

    fn next_u8(&self) -> u8 {
        self.borrow_csprng().next_u8()
    }

    fn next_u32(&self) -> u32 {
        self.borrow_csprng().next_u32()
    }

    fn next_u64(&self) -> u64 {
        self.borrow_csprng().next_u64()
    }

    fn next_u128(&self) -> u128 {
        self.borrow_csprng().next_u128()
    }

    fn next_biguint(&self, bits: NonZeroUsize) -> BigUint {
        self.borrow_csprng().next_biguint(bits)
    }

    fn next_biguint_requiring_bits(&self, bits: NonZeroUsize) -> BigUint {
        self.borrow_csprng().next_biguint_requiring_bits(bits)
    }

    fn next_biguint_lt(&self, end: &BigUint) -> Option<BigUint> {
        self.borrow_csprng().next_biguint_lt(end)
    }

    fn next_biguint_range(&self, start: &BigUint, end: &BigUint) -> Option<BigUint> {
        self.borrow_csprng().next_biguint_range(start, end)
    }

    fn next_u32_range(&self, start: u32, end: u32) -> Option<u32> {
        let distr = Uniform::new(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_u32_rangeinclusive(&self, start: u32, end: u32) -> Option<u32> {
        let distr = Uniform::new_inclusive(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_usize_range(&self, start: usize, end: usize) -> Option<usize> {
        let distr = Uniform::new(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_usize_rangeinclusive(&self, start: usize, end: usize) -> Option<usize> {
        let distr = Uniform::new_inclusive(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_u64_range(&self, start: u64, end: u64) -> Option<u64> {
        let distr = Uniform::new(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_u64_rangeinclusive(&self, start: u64, end: u64) -> Option<u64> {
        let distr = Uniform::new_inclusive(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }
}

//=================================================================================================|
