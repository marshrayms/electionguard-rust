// Copyright (C) Microsoft Corporation. All rights reserved.

#![allow(clippy::expect_used)] // This is build code
#![allow(clippy::manual_assert)] // This is build code
#![allow(clippy::panic)] // This is build code
#![allow(clippy::unwrap_used)] // This is build code
#![allow(clippy::assertions_on_constants)]
#![allow(clippy::type_complexity)]
//? #![allow(non_snake_case)] // This module needs to talk about types in function names
//-
#![allow(dead_code)] //? TODO: Remove temp development code
#![allow(unused_assignments)] //? TODO: Remove temp development code
#![allow(unused_imports)] //? TODO: Remove temp development code
#![allow(unused_variables)] //? TODO: Remove temp development code
#![allow(unreachable_code)] //? TODO: Remove temp development code
#![allow(non_camel_case_types)]
//? TODO: Remove temp development code
//? #![allow(non_snake_case)] //? TODO: Remove temp development code
#![allow(noop_method_call)] //? TODO: Remove temp development code
#![allow(unused_braces)] //? TODO: Remove temp development code

use core::num;
use std::{
    collections::BTreeSet,
    env,
    fs::{self, File},
    io::{BufRead, BufWriter, Read, Write},
    path::{Path, PathBuf},
    rc::Rc,
};

use anyhow::{Context, Result, anyhow, bail, ensure};
use proc_macro2::token_stream;
use quote::ToTokens;
use syn::{Field, Pat};

use crate::build_mod::*;
use crate::*;

//=================================================================================================|

const TYPES_METADATA_INC_RS_FILENAME: &str = "types_metadata.inc.rs";
const GENERATED_TYPES_INC_RS_FILENAME: &str = "generated_types.inc.rs";
const GENERATED_MACROS_INC_RS_FILENAME: &str = "generated_macros.inc.rs";

pub const GENERATED_FILE_COMMENT_HEADER: &str = "// NOTE: This file is automatically generated.\n";

//-------------------------------------------------------------------------------------------------|

struct ModuleAndFilename {
    type_info: &'static TypeInfoStruct,
    author: Box<dyn Author>,
    out_filename: String,
    out_file_full_path: PathBuf,
    opt_ofw: Option<BufWriter<File>>,
}

pub fn write_files() -> Result<()> {
    let out_dir = get_verified_out_dir()?;

    //println!("cargo:warning=DEBUG: OUT_DIR: {}", out_dir.display());

    //for f in Feature::all_enabled_features() { println!("cargo:warning=INFO: Feature enabled: {f:?}"); }

    // Figure out what module files we'll need to create.
    let mut v_module_and_filenames: Vec<ModuleAndFilename> = vec![];
    for type_author in all_type_authorings()? {
        let type_info: &'static TypeInfoStruct = &type_author.type_info;

        let fn_new_author = type_author.numimpl_author.bx_new_author;
        let author = fn_new_author(type_info)?;
        author.verify_basics()?;

        let out_filename = type_author.out_filename().clone();
        //println!("cargo:warning=DEBUG: OUT_DIR/{out_filename}");

        let out_file_full_path = out_dir.join(out_filename.clone());

        v_module_and_filenames.push(ModuleAndFilename {
            type_info,
            author,
            out_filename,
            out_file_full_path,
            opt_ofw: None,
        });
    }

    // Ask the module authors what `use` decls they need.
    let mut module_usedeclsets = ModuleName_to_UsedeclSet::new();
    for mandf in v_module_and_filenames.iter() {
        let module_name = mandf.type_info.module_name();
        mandf
            .author
            .accumulate_usedecls_top(module_usedeclsets.get_mut(module_name))?;
    }

    // Create the module files and write the main part.
    for mandf in v_module_and_filenames.iter_mut() {
        let mut ofw = create_file(&mandf.out_file_full_path)?;
        mandf.author.write_whole_file(&mut ofw)?;
        mandf.opt_ofw = Some(ofw);
    }

    // Write the parts of the module files that involve conversions between multiple types.
    for mandf_ix_rhs in 1..v_module_and_filenames.len() {
        let (sl, sr) = v_module_and_filenames.split_at_mut(mandf_ix_rhs);
        let mandf_rhs = &mut sr[0];
        let ofw_rhs = mandf_rhs.opt_ofw.as_mut().unwrap();
        for mandf_lhs in sl {
            let ofw_lhs = mandf_lhs.opt_ofw.as_mut().unwrap();
            mandf_lhs
                .author
                .write_conversions_from(ofw_lhs, mandf_rhs.type_info)?;
            mandf_rhs
                .author
                .write_conversions_from(ofw_rhs, mandf_lhs.type_info)?;
        }
    }

    // Close the module files.
    for mandf in v_module_and_filenames.iter_mut() {
        let mut ofw = mandf.opt_ofw.take().unwrap();
        ofw.flush()?;
        let f = ofw.into_inner()?;
        f.sync_all()?;
        drop(f); // File is closed
    }

    // Write `generated_types.inc.rs` file defining the modules.
    write_generated_types_inc_rs(&out_dir, &v_module_and_filenames, &mut module_usedeclsets)?;

    // Write `types_data.inc.rs` file listing the types for crate users.
    let (numimpls, niix_typeinfos) = figure_numimpls_and_typeinfos(&v_module_and_filenames)?;
    write_types_metadata_inc_rs(&out_dir, &numimpls, &niix_typeinfos)?;

    // Write `generated_macros.inc.rs` file listing the types for crate users.
    write_generated_macros_inc_rs(&out_dir, &numimpls, &niix_typeinfos)?;

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn get_verified_out_dir() -> Result<PathBuf> {
    let out_dir = env::var_os("OUT_DIR").ok_or_else(|| anyhow!("No OUT_DIR env var."))?;

    let out_dir = PathBuf::from(out_dir);
    ensure!(out_dir.try_exists()?, "OUT_DIR does not exist: {out_dir:?}");
    ensure!(
        fs::metadata(&out_dir)?.is_dir(),
        "OUT_DIR does not exist: {out_dir:?}"
    );

    Ok(out_dir)
}

//-------------------------------------------------------------------------------------------------|

fn create_file<P: AsRef<Path>>(file_path: P) -> Result<BufWriter<File>> {
    let file_path: &Path = file_path.as_ref();
    //println!(
    //    "cargo:warning=INFO: writing {}",
    //    file_path.file_name().unwrap_or_default().to_string_lossy()
    //);

    let of = File::create(file_path)?;
    let write_buf_capacity = 1 << 17; // 128 KiB
    let bw = BufWriter::with_capacity(write_buf_capacity, of);
    Ok(bw)
}

//-------------------------------------------------------------------------------------------------|

fn close_file(mut bw: BufWriter<File>) -> Result<()> {
    bw.flush()?;
    let f = bw.into_inner()?;
    f.sync_all()?;
    drop(f); // File is closed
    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_usedecls_for_module<S: std::string::ToString>(
    of: &mut dyn std::io::Write,
    module_name: S,
    usedecl_set: &UsedeclSet,
) -> Result<()> {
    use std::fmt::Write;

    let mut buf = String::new();

    for v_str in usedecl_set.0.iter() {
        buf.write_str("    use ")?;
        for (ix, s) in v_str.iter().enumerate() {
            let cc = if ix == 0 && s == "crate" { "" } else { "::" };
            buf.write_fmt(format_args!("{cc}{s}"))?;
        }
        buf.write_str(";\n")?;
    }

    of.write_all(buf.as_bytes())?;

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_types_inc_rs(
    out_dir: &Path,
    v_module_and_filenames: &[ModuleAndFilename],
    module_usedeclsets: &mut ModuleName_to_UsedeclSet,
) -> Result<()> {
    let file_path = out_dir.join(GENERATED_TYPES_INC_RS_FILENAME);
    let mut bw = create_file(&file_path)?;
    bw.write_all(GENERATED_FILE_COMMENT_HEADER.as_bytes())?;

    let mut opt_prev_module_name = None;
    for mandf in v_module_and_filenames.iter() {
        let module_name = mandf.type_info.module_name();
        let out_filename = &mandf.out_filename;

        if opt_prev_module_name != Some(module_name.clone()) {
            if opt_prev_module_name.is_some() {
                bw.write_all(b"}\n")?;
            }

            bw.write_all(format!("\npub mod {module_name} {{\n").as_bytes())?;

            let usedecl_set = module_usedeclsets.get_mut(module_name);

            write_usedecls_for_module(&mut bw, module_name, usedecl_set)?;
        }

        let line = format!("    include!(concat!(env!(\"OUT_DIR\"), \"/{out_filename}\"));\n");
        bw.write_all(line.as_bytes())?;

        opt_prev_module_name = Some(module_name.clone());
    }

    if opt_prev_module_name.is_some() {
        bw.write_all(b"}\n")?;
    }

    close_file(bw)
    //.and_then(|| read_and_log_file(out_dir, &file_path))
}

//-------------------------------------------------------------------------------------------------|

fn figure_numimpls_and_typeinfos(
    module_and_filenames: &[ModuleAndFilename],
) -> Result<(
    Vec<&'static NumericImplStruct>,
    Vec<(usize, &'static TypeInfoStruct)>,
)> {
    let mut numimpls = Vec::<&'static NumericImplStruct>::new();
    let mut niix_typeinfos = Vec::<(usize, &'static TypeInfoStruct)>::new();

    for mandf in module_and_filenames.iter() {
        let type_info = mandf.type_info;
        let numimpl = type_info.numimpl;

        // See if we already have this numimpl, otherwise, add it.
        let ni_ix = {
            let mut opt_ni_ix = None;
            for (ix, &ni) in numimpls.iter().enumerate() {
                // Reference equality comparisons are rare in Rust, but it appears to be valid:
                // https://users.rust-lang.org/t/is-any-way-to-know-references-are-referencing-the-same-object/9716/6
                if std::ptr::eq(ni, numimpl) {
                    opt_ni_ix = Some(ix);
                    break;
                }
            }

            opt_ni_ix.unwrap_or_else(|| {
                let ix = numimpls.len();
                numimpls.push(numimpl);
                ix
            })
        };

        niix_typeinfos.push((ni_ix, type_info));
    }

    Ok((numimpls, niix_typeinfos))
}

//-------------------------------------------------------------------------------------------------|

fn read_and_log_file(out_dir: &Path, file_path: &Path) -> Result<()> {
    fn imp(out_dir: &Path, file_path: &Path) -> Result<()> {
        let f = File::open(file_path)?;
        let read_buf_capacity = 1 << 17; // 128 KiB
        let br = std::io::BufReader::with_capacity(read_buf_capacity, f);

        let mut base_dir = out_dir.to_path_buf(); // println!("cargo:warning=DEBUG: base_dir: {}", base_dir.display());
        base_dir.pop(); // println!("cargo:warning=DEBUG: base_dir: {}", base_dir.display());
        base_dir.pop(); // println!("cargo:warning=DEBUG: base_dir: {}", base_dir.display());
        base_dir.pop(); // println!("cargo:warning=DEBUG: base_dir: {}", base_dir.display());
        base_dir.pop();
        println!("cargo:warning=DEBUG: base_dir: {}", base_dir.display());

        let rel_path = file_path.strip_prefix(base_dir).unwrap_or(file_path);

        println!(
            "cargo:warning=DEBUG: vvvvvvvvvvvvvvvvvv {} vvvvvvvvvvvvvvvvvv",
            rel_path.display()
        );

        for line in br.lines() {
            println!("cargo:warning=DEBUG: {}", line?);
        }

        println!(
            "cargo:warning=DEBUG: ^^^^^^^^^^^^^^^^^^ {} ^^^^^^^^^^^^^^^^^^",
            rel_path.display()
        );

        Ok(())
    }

    if let Err(err) = imp(out_dir, file_path) {
        println!("cargo:warning=WARN: {err}");
    }

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

#[rustfmt::skip]
fn write_types_metadata_inc_rs(
    out_dir: &Path,
    numimpls: &Vec<&'static NumericImplStruct>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    let file_path = out_dir.join(TYPES_METADATA_INC_RS_FILENAME);
    let mut bw = create_file(&file_path)?;
    bw.write_all(GENERATED_FILE_COMMENT_HEADER.as_bytes())?;


    bw.write_all(br##"
mod __nonpublic2 {

    use crate::types::{
        __nonpublic::{self, NumericImplStruct, TypeInfoStruct},
        CowStaticStr,
        LimbType,
        Subtype,
    };
"##)?;

    write_types_metadata_inc_rs_numimpls(&mut bw, numimpls)?;
    write_types_metadata_inc_rs_type_infos(&mut bw, niix_typeinfos)?;

    bw.write_all(b"\n}\n")?;

    close_file(bw)
    //.and_then(|| read_and_log_file(out_dir, &file_path))
}

//-------------------------------------------------------------------------------------------------|

#[rustfmt::skip]
fn write_types_metadata_inc_rs_numimpls(
    bw: &mut BufWriter<File>,
    numimpls: &Vec<&'static NumericImplStruct>,
) -> Result<()> {
    use proc_macro2::{Group, Punct, Spacing::{self, Alone}, TokenTree};

    bw.write_all(b"\n    //================ `NumericImpl`s\n")?;

    //? TODO array.each_ref() is coming in rust 1.77, which might eliminate the need for num
    // https://github.com/rust-lang/rust/issues/76118

    let numimpls_len_literal = Literal::usize_unsuffixed(numimpls.len());
    let numimpls_ixs = 0..numimpls.len();
    write_tokens!(bw, "\n", quote! {
        #[allow(dead_code)]
        pub(crate) const NUMIMPLS: [NumericImplStruct; #numimpls_len_literal] = [ #( #numimpls ),* ];
    })?;

    let numimpls_ixs = 0..numimpls.len();
    write_tokens!(bw, "\n", quote! {
        #[allow(dead_code)]
        pub(crate) const NUMIMPLS_REFS: [&NumericImplStruct; #numimpls_len_literal] =
            [ #( & NUMIMPLS[ #numimpls_ixs ] ),* ];
    })
}

//-------------------------------------------------------------------------------------------------|

fn write_types_metadata_inc_rs_type_infos(
    bw: &mut BufWriter<File>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    use proc_macro2::{
        Group, Punct,
        Spacing::{self, Alone},
        TokenTree,
    };

    bw.write_all(b"\n    //================ `TypeInfo`s\n")?;

    let typeinfos_len_literal = Literal::usize_unsuffixed(niix_typeinfos.len());

    // Fix up the `#` we left in the TypeInfoStruct::numimpl field initializer to
    // an expression referencing the correct NUMIMPLS array element.
    let mut v_ti_ts = vec![];
    for &(ni_ix, type_info) in niix_typeinfos {
        let ni_ix_literal = Literal::usize_unsuffixed(ni_ix);
        let ts = quote! { #type_info };
        let mut ts2 = TokenStream::new();
        for tt in ts {
            if let TokenTree::Group(g) = &tt {
                let mut ts3 = TokenStream::new();
                for tt2 in g.stream() {
                    let mut tt2_eaten = false;
                    if let TokenTree::Punct(p) = &tt2 {
                        if p.as_char() == '#' && p.spacing() == Alone {
                            ts3.append_all(quote! { &NUMIMPLS[#ni_ix_literal] });
                            tt2_eaten = true;
                        }
                    }

                    if !tt2_eaten {
                        ts3.append(tt2);
                    }
                }
                ts2.append(TokenTree::Group(Group::new(g.delimiter(), ts3)))
            } else {
                ts2.append(tt);
            }
        }

        v_ti_ts.push(ts2);
    }

    write_tokens!(
        bw,
        "\n#[allow(dead_code)]\n",
        quote! {
            pub(crate) const TYPEINFOS: [__nonpublic::TypeInfoStruct; #typeinfos_len_literal] = [ #( #v_ti_ts ),* ];
        }
    )?;

    let typeinfo_ixs = (0..v_ti_ts.len()).map(Literal::usize_unsuffixed);
    write_tokens!(
        bw,
        "\n#[allow(dead_code)]\n",
        quote! {
            pub(crate) const TYPEINFOS_REFS: [&TypeInfoStruct; #typeinfos_len_literal] =
                [ #( & TYPEINFOS[ #typeinfo_ixs ] ),* ];
        }
    )
}

//-------------------------------------------------------------------------------------------------|

#[rustfmt::skip]
fn write_generated_macros_inc_rs(
    out_dir: &Path,
    numimpls: &Vec<&'static NumericImplStruct>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    let file_path = out_dir.join(GENERATED_MACROS_INC_RS_FILENAME);
    let mut bw_ = create_file(&file_path)?;
    let bw = &mut bw_;
    bw.write_all(GENERATED_FILE_COMMENT_HEADER.as_bytes())?;

    use std::fmt::Write;
    bw.write_all(br##"
//================ Macros
"##)?;

    write_generated_macros_inc_rs_module_name_eq(bw)?;

    write_generated_macros_inc_rs_for_each_nonnegative_impl(bw, numimpls, niix_typeinfos)?;
    write_generated_macros_inc_rs_for_each_nonnegative_type(bw, niix_typeinfos)?;
    write_generated_macros_inc_rs_for_each_nonnegative_type_make_unique_test_mod(bw, niix_typeinfos)?;
    write_generated_macros_inc_rs_for_each_nonnegative_type_about_unique_test_mod(bw, niix_typeinfos)?;
    write_generated_macros_inc_rs_for_each_numimpl_limbtype_nonnegative_code_block(bw, niix_typeinfos)?;
    write_generated_macros_inc_rs_type_name_eq(bw, niix_typeinfos)?;
    write_generated_macros_inc_rs_bits_eq(bw)?;

bw.write_all(br##"
//================
"##)?;

    close_file(bw_)
    //.and_then(|| read_and_log_file(out_dir, &file_path))
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_module_name_eq(
    bw: &mut BufWriter<File>,
    //niix_typeinfos_: &[(usize, &'static TypeInfoStruct)],
) -> Result<()> {
    bw.write_all(
        br##"
//---------------- ...

"##,
    )?;

    for module_name in all_possible_module_names_from_all_inventoried_numimpl_authors() {
        bw.write_fmt(format_args!(
            r##"
#[allow(unused_macros)]
#[macro_export]
macro_rules! module_name_eq_{module_name} {{
    ({module_name:>15}  => {{ $( $stuff:tt )* }}) => {{ $($stuff)* }};
    ($module_name:ident => {{ $( $stuff:tt )* }}) => {{ }};
}}
"##
        ))?;
    }

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_for_each_nonnegative_impl(
    bw: &mut BufWriter<File>,
    numimpls: &Vec<&'static NumericImplStruct>,
    niix_typeinfos: &[(usize, &'static TypeInfoStruct)],
) -> Result<()> {
    bw.write_all(
        br##"
//---------------- For each numeric implementation...

// To use this, define a callback macro like:
//
// ```text
// macro_rules! my_cb_for_each_nonnegative_impl {
//     ($numimpl_ix:literal, $numimpl_crate_name:literal, $my_param:literal) => {{
//         use crate::types::NumericImpl;
//         let numimpl = crate::types::all_numimpls()[$numimpl_ix];
//         let crate_name = numimpl.crate_name();
//         println!("NUMIMPL[{}] crate name: {crate_name}, my_param: {:?}", $numimpl_ix, $my_param);
//         assert_eq!($numimpl_crate_name, crate_name);
//         assert_eq!($my_param, "my_param_value");
//     }};
// }
// ```
//
// Then call it like:
//
// ```text
// for_each_nonnegative_impl!(my_cb_for_each_nonnegative_impl("my_param_value"));
// ```
//
#[macro_export]
macro_rules! for_each_nonnegative_impl {
    ($callback_each_numimpl:ident( $($args:tt)* )) => {
"##,
    )?;

    for (numimpl_ix, &numimpl) in numimpls.iter().enumerate() {
        bw.write_fmt(format_args!(
            "        $callback_each_numimpl!( {numimpl_ix}, {:?}, $( $args )* );\n",
            numimpl.crate_name(),
        ))?;
    }

    bw.write_all(
        br##"
    };
}
"##,
    )?;

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_for_each_nonnegative_type(
    bw: &mut BufWriter<File>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    bw.write_all(
        br##"
//---------------- For each `Subtype::Nonnegative` type...

#[allow(unused_macros)]
#[macro_export]
macro_rules! for_each_nonnegative_type {
    ($callback_each_nonnegative_type:ident( $($args:tt)* )) => {
"##,
    )?;

    for (type_info_ix, &(_numimpl_ix, type_info)) in niix_typeinfos.iter().enumerate() {
        if type_info.subtype() != Subtype::Nonnegative {
            continue;
        }

        bw.write_fmt(format_args!(
            "        $callback_each_nonnegative_type!({}, {}, {}, {}, $($args)* );\n",
            type_info_ix, type_info.module_name, type_info.type_name, type_info.bits,
        ))?;
    }

    bw.write_all(
        br##"
    };
}
"##,
    )?;

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_for_each_nonnegative_type_make_unique_test_mod(
    bw: &mut BufWriter<File>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    bw.write_all(
        br##"
//---------------- For each `Subtype::Nonnegative` type...

/// For each `Subtype::Nonnegative` type... create a test module with a unique name.
///
/// Intended to be invoked in file or module scope.
#[allow(unused_macros)]
#[macro_export]
macro_rules! for_each_nonnegative_type_make_unique_test_mod {
    ($callback_each_nonnegative_type:ident( $($args:tt)* )) => {
"##,
    )?;

    for (type_info_ix, &(numimpl_ix, type_info)) in niix_typeinfos.iter().enumerate() {
        if type_info.subtype() != Subtype::Nonnegative {
            continue;
        }

        let test_module_name = format!("{}_{}", type_info.module_name, type_info.type_name);
        let type_name = &type_info.type_name;
        let module_name = &type_info.module_name;
        let bits = type_info.bits;

        bw.write_fmt(format_args!(
            r##"
pub(crate) mod {test_module_name} {{
    $callback_each_nonnegative_type!(
        {test_module_name},
        {numimpl_ix},
        {type_info_ix},
        {module_name},
        ::fixed_width_nonnegative::{module_name},
        {type_name},
        ::fixed_width_nonnegative::{module_name}::{type_name},
        {bits},
        $($args)* );
}}
"##
        ))?;
    }

    bw.write_all(
        br##"
    };
}
"##,
    )?;

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_for_each_nonnegative_type_about_unique_test_mod(
    bw: &mut BufWriter<File>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    bw.write_all(br##"
//---------------- For each numeric type...

/// For each numeric type with Subtype::Nonnegative... call back with test module info.
///
/// Intended to be invoked in block scope, however, the identifiers probably need to resolve to something.
/// So you probably need to have used `for_each_nonnegative_type_make_unique_test_mod` somewhere accessible.
///
/// ```text
/// macro_rules! cb_for_each_nonnegative_type_do_stuff {
/// (
///     $test_module_name:ident,
///     $numimpl_ix:literal,
///     $type_info_ix:literal,
///     $module_name:ident,
///     $module_name_fq:path,
///     $limb_type:ident,
///     $limb_type_fq:path,
///     $type_name:ident,
///     $type_name_fq:path,
///     $bits:tt,
/// ) => {{
///     const NUMIMPL_IX: usize = $numimpl_ix;
///     const MODULE_NAME_S: &'static str = stringify!($module_name);
///     const MODULE_NAME_FQ_S: &'static str = stringify!($module_name_fq);
///     const LIMB_TYPE_S: &'static str = stringify!($limb_type);
///     const LIMB_TYPE_FQ_S: &'static str = stringify!($limb_type_fq);
///     const TYPE_NAME_S: &'static str = stringify!($type_name);
///     const TYPE_NAME_FQ_S: &'static str = stringify!($type_name_fq);
///
///     debug!("vvvvvvvvvvvvvvvvvv module_name_fq: {}, limb_type: {} vvvvvvvvvvvvvvvvvv", $module_name_fq, $limb_type);
///
///     fixed_width_nonnegative::bits_eq_4096! { $bits => {
///         let s = format!("{:0X}", $type_name_fq_path::all_ones());
///         assert_eq!(s, "F".repeat(4096/4));
///     } };
///
///     debug!("^^^^^^^^^^^^^^^^^^ module_name_fq: {}, limb_type: {} ^^^^^^^^^^^^^^^^^^");
/// }};
/// }
/// ```
///
/// fixed_width_nonnegative::for_each_nonnegative_type_about_unique_test_mod!(
/// cb_for_each_nonnegative_type_do_stuff()
/// );
///
///
#[allow(unused_macros)]
#[macro_export]
macro_rules! for_each_nonnegative_type_about_unique_test_mod {
    ($callback_for_each_nonnegative_type_about_unique_test_mod:ident( $($args:tt)* )) => {
"##)?;
    for (type_info_ix, &(numimpl_ix, type_info)) in niix_typeinfos.iter().enumerate() {
        if type_info.subtype() != Subtype::Nonnegative {
            continue;
        }

        let test_module_name = format!("{}_{}", type_info.module_name, type_info.type_name);
        let type_name = type_info.type_name();
        let module_name = type_info.module_name();
        let limb_type = type_info.limb_type();
        let limb_type_s = limb_type.to_string();
        let bits = type_info.bits();

        bw.write_fmt(format_args!(
            r##"
    $callback_for_each_nonnegative_type_about_unique_test_mod!(
        {test_module_name},
        {numimpl_ix},
        {type_info_ix},
        {module_name},
        ::fixed_width_nonnegative::{module_name},
        {limb_type_s},
        ::fixed_width_nonnegative::types::LimbType::{limb_type_s},
        {type_name},
        ::fixed_width_nonnegative::{module_name}::{type_name},
        {bits},
        $($args)* );
"##
        ))?;
    }

    bw.write_all(
        br##"
    };
}
"##,
    )?;

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_for_each_numimpl_limbtype_nonnegative_code_block(
    bw: &mut BufWriter<File>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    bw.write_all(br##"
//---------------- Expand macro for each unique combination of numimpl and limb type

/// For each unique combination of numimpl and limb type with Subtype::Nonnegative ... call back in block.
///
/// Intended to be invoked in block scope, however, the identifiers probably need to resolve to something.
/// So you may need to have used `for_each_nonnegative_type_make_unique_test_mod` somewhere accessible.
///
#[macro_export]
macro_rules! for_each_numimpl_limbtype_nonnegative_code_block {
    ($cb_for_each_numimpl_limbtype_nonnegative_code_block:ident( $($args:tt)* )) => {
"##)?;
    type NumimplLimbInfo = (
        usize,
        &'static CowStaticStr,
        &'static CowStaticStr,
        LimbType,
    );

    enum OpenClose {
        Open,
        Close,
    }
    use OpenClose::*;
    let block_open_close = |bw: &mut BufWriter<File>,
                            numimpl_limb_info: &NumimplLimbInfo,
                            open_close: OpenClose|
     -> Result<()> {
        let &(numimpl_ix, module_name, module_name_fq, limb_type) = numimpl_limb_info;
        let limb_type_s = limb_type.to_string();
        let limb_type_fq = format!("::fixed_width_nonnegative::types::LimbType::{limb_type}");
        match open_close {
            Open => {
                bw.write_fmt(format_args!(
r##"        // NUMIMPL_IX: {numimpl_ix}, module_name: {module_name}, module_name_fq: {module_name_fq}, LIMB_TYPE: {limb_type_s}, limb_type_fq: {limb_type_fq}
        {{
            #[allow(unused_macros)]
            macro_rules! type_name_fq_for_bits {{
"##))
                }
            Close => {
                bw.write_fmt(format_args!(
r##"            }}
            {{
                const NUMIMPL_IX: usize = {numimpl_ix};
                const MODULE_NAME_S: &'static str = {module_name:?};
                const MODULE_NAME_FQ_S: &'static str = {module_name_fq:?};
                const LIMB_TYPE_S: &'static str = {limb_type_s:?};
                const LIMB_TYPE_FQ_S: &'static str = {limb_type_fq:?};

                // User code emitted here.
                $cb_for_each_numimpl_limbtype_nonnegative_code_block!(
                    {module_name_fq}, // module_name_fq
                    {limb_type_fq}, // limb_type_fq
                    $($args)* );
            }}
        }}
"##))
            }
        }.map_err(Into::into)
    };

    let mut opt_prev_numimpl_limb_info: Option<NumimplLimbInfo> = None;
    let mut is_opened = false;
    for (type_info_ix, &(numimpl_ix, type_info)) in niix_typeinfos.iter().enumerate() {
        if type_info.subtype() != Subtype::Nonnegative {
            continue;
        }

        let numimpl_limb_info: NumimplLimbInfo = (
            numimpl_ix,
            type_info.module_name(),
            type_info.module_name_fq(),
            type_info.limb_type(),
        );

        #[allow(clippy::collapsible_else_if)] //? TODO clippy
        if let Some(prev_numimpl_limb_info) = &opt_prev_numimpl_limb_info {
            if is_opened && prev_numimpl_limb_info != &numimpl_limb_info {
                block_open_close(bw, prev_numimpl_limb_info, Close)?;
                is_opened = false;
            }
        } else {
            if !is_opened {
                block_open_close(bw, &numimpl_limb_info, Open)?;
                is_opened = true;
            }
        }

        if type_info.subtype() != Subtype::Nonnegative {
            break;
        }

        if !is_opened {
            block_open_close(bw, &numimpl_limb_info, Open)?;
            is_opened = true;
        }

        let bits = type_info.bits();
        let type_name_fq = type_info.type_name_fq();
        bw.write_fmt(format_args!(
            "                ( {bits:>5} ) => {{ {type_name_fq} }};\n"
        ))?;

        opt_prev_numimpl_limb_info = Some(numimpl_limb_info);
    }

    if is_opened {
        if let Some(prev_numimpl_limb_info) = &opt_prev_numimpl_limb_info {
            block_open_close(bw, prev_numimpl_limb_info, Close)?;
        }
    }

    bw.write_all(
        br##"    };
}
"##,
    )?;

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_bits_eq(bw: &mut BufWriter<File>) -> Result<()> {
    bw.write_all(
        br##"
//---------------- Expand code if bits are a certain value

"##,
    )?;

    // Accumulate all powers of two up to 65536 and all the values of bits in known features.
    let mut set_bits: BTreeSet<usize> = Feature::all_buildrs_knownfeature_bitses_usize()
        .iter()
        .copied()
        .collect();
    set_bits.extend((0..=16_u8).map(|l2| 1_usize << l2));

    for bits in set_bits {
        bw.write_fmt(format_args!(
            r##"
/// Expand code if bits == {bits}.
///
/// You can use this in a macro expansion that provides `$bits` to emit code only
/// for certai:
///
/// ```text
/// macro_rules! my_callback_for_each_bits {{
///     ($type_name_fq:path, $bits:tt) => {{
///         bits_eq_{bits}!( $bits =>
///             pub fn make_a_{bits}_bit_number() -> $type_name_fq {{
///                 $type_name_fq::max()
///             }});
///     }};
/// }}
/// ```
///
/// Note that in the outer macro the `$bits` parameter must be matched as `:tt`. Matching
/// it as `:literal` breaks the necessary matching behavior in macros for some reason.
///
#[allow(unused_macros)]
#[macro_export]
macro_rules! bits_eq_{bits} {{
    ({bits:>8} => {{ $( $stuff:tt )* }}) => {{ $($stuff)* }};
    ($bits:tt  => {{ $( $stuff:tt )* }}) => {{ }};
}}
"##
        ))?;
    }

    Ok(())
}

//-------------------------------------------------------------------------------------------------|

fn write_generated_macros_inc_rs_type_name_eq(
    bw: &mut BufWriter<File>,
    niix_typeinfos: &Vec<(usize, &'static TypeInfoStruct)>,
) -> Result<()> {
    bw.write_all(
        br##"
//---------------- ...

"##,
    )?;

    let mut all_type_names = BTreeSet::<CowStaticStr>::new();
    for &(_numimpl_ix, type_info) in niix_typeinfos.iter() {
        all_type_names.insert(type_info.type_name().clone());
    }

    for type_name in all_type_names {
        bw.write_fmt(format_args!(
            r##"
#[allow(unused_macros)]
#[macro_export]
macro_rules! type_name_eq_{type_name} {{
    ({type_name:>15}  => {{ $( $stuff:tt )* }}) => {{ $($stuff)* }};
    ($type_name:ident => {{ $( $stuff:tt )* }}) => {{ }};
}}
"##
        ))?;
    }

    Ok(())
}

//-------------------------------------------------------------------------------------------------|
