// Copyright (C) Microsoft Corporation. All rights reserved.

//#![cfg_attr(rustfmt, rustfmt_skip)]
#![deny(clippy::expect_used)]
#![deny(clippy::manual_assert)]
#![deny(clippy::panic)]
#![deny(clippy::unwrap_used)]
#![allow(clippy::assertions_on_constants)]
#![allow(dead_code)] //? TODO: Remove temp development code
#![allow(unused_assignments)] //? TODO: Remove temp development code
#![allow(unused_braces)] //? TODO: Remove temp development code
#![allow(unused_imports)] //? TODO: Remove temp development code
#![allow(unused_mut)] //? TODO: Remove temp development code
#![allow(unused_variables)] //? TODO: Remove temp development code
#![allow(unreachable_code)] //? TODO: Remove temp development code
#![allow(non_camel_case_types)] //? TODO: Remove temp development code
#![allow(non_snake_case)] //? TODO: Remove temp development code
#![allow(noop_method_call)] //? TODO: Remove temp development code

use std::{
    borrow::BorrowMut,
    num::NonZeroUsize,
    ops::RangeInclusive,
    sync::{Mutex, MutexGuard},
};

use num_bigint::BigUint;
use rand::{
    RngCore,
    distr::{Distribution, Uniform},
};
use static_assertions::assert_impl_all;

use crate::csprng::Csprng;

//=================================================================================================|

/// Trait expressing operations provided by a CSRNG. Similar to the interface provided by
/// [`util::Csprng`], but since this interface is notionally stateless it requires
/// only a shared reference.
///
pub trait Csrng {
    /// Fills the supplied buffer with generated bytes.
    ///
    /// Compare to `rand::RngCore::fill_bytes`.
    fn fill_buf(&self, buf: &mut [u8]);

    /// Returns a uniformly random `bool`.
    fn next_bool(&self) -> bool;

    /// Returns a uniformly random `u8`.
    fn next_u8(&self) -> u8;

    /// Returns a uniformly random `u32`.
    fn next_u32(&self) -> u32;

    /// Returns a uniformly random `u64`.
    fn next_u64(&self) -> u64;

    /// Returns a uniformly random `u128`.
    fn next_u128(&self) -> u128;

    // Returns a random number chosen uniformly from 0 <= n < 2^bits.
    fn next_biguint(&self, bits: NonZeroUsize) -> BigUint;

    /// Returns a random number that requires exactly the specified number of bits to represent.
    /// If `bits == 1`, chosen uniformly `0` or `1`.
    /// else `bits > 1`, chosen uniformly from `2^(bits - 1) <= n < 2^bits`.
    /// I.e., the high bit position `bits - 1` is guaranteed to be set, but all lower
    /// bit positions are uniform random.
    fn next_biguint_requiring_bits(&self, bits: NonZeroUsize) -> BigUint;

    /// Returns a random number uniformly from `0 <= n < end`.
    /// `end` must be greater than `0`.
    fn next_biguint_lt(&self, end: &BigUint) -> Option<BigUint>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_biguint_range(&self, start: &BigUint, end: &BigUint) -> Option<BigUint>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_u32_range(&self, start: u32, end: u32) -> Option<u32>;

    /// Returns a random number uniformly from `start <= n <= end`.
    /// `start` must be less or equal to `end`.
    fn next_u32_rangeinclusive(&self, start: u32, end: u32) -> Option<u32>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_usize_range(&self, start: usize, end: usize) -> Option<usize>;

    /// Returns a random number uniformly from `start <= n <= end`.
    /// `start` must be less or equal to `end`.
    fn next_usize_rangeinclusive(&self, start: usize, end: usize) -> Option<usize>;

    /// Returns a random number uniformly from `start <= n < end`.
    /// `start` must be less than `end`.
    fn next_u64_range(&self, start: u64, end: u64) -> Option<u64>;

    /// Returns a random number uniformly from `start <= n <= end`.
    /// `start` must be less or equal to `end`.
    fn next_u64_rangeinclusive(&self, start: u64, end: u64) -> Option<u64>;
}

/// Operations provided by a CSRNG which can be implemented using the [`Csrng`] trait, but would
/// make it not object-safe.
///
pub trait CsrngOps {
    /// Returns an array of uniformly random `u8`s.
    fn next_arr_u8<const N: usize>(&self) -> [u8; N];
}

impl<T> CsrngOps for T
where
    T: Csrng + ?Sized,
{
    fn next_arr_u8<const N: usize>(&self) -> [u8; N] {
        let mut buf = [0_u8; N];
        self.fill_buf(&mut buf);
        buf
    }
}

//=================================================================================================|

/// Wraps a [`Csprng`] and uses interior mutability to provide a [`Csrng`] interface.
pub struct DeterministicCsrng(Mutex<Csprng>);

impl DeterministicCsrng {
    /// Creates a new [`DeterministicCsrng`] wrapping the provided [`Csprng`].
    #[inline]
    pub fn new(csprng: Csprng) -> DeterministicCsrng {
        Self(Mutex::new(csprng))
    }

    /// Creates a new [`DeterministicCsrng`] using a [`Csprng`] initialized from
    /// a sequence of bytes preceded by its length as a big-endian u64.
    #[inline]
    pub fn from_seed_bytes<AsRefSliceU8>(seed_bytes: AsRefSliceU8) -> Self
    where
        AsRefSliceU8: AsRef<[u8]>,
    {
        Self::new(Csprng::from_seed_bytes(seed_bytes))
    }

    /// Creates a new [`DeterministicCsrng`] using a [`Csprng`] initialized from
    /// a [`UTF-8 string`](std::string::str)  preceded by its length in bytes as a big-endian u64.
    #[inline]
    pub fn from_seed_str<AsRefStr>(seed_str: AsRefStr) -> Self
    where
        AsRefStr: AsRef<str>,
    {
        Self::new(Csprng::from_seed_str(seed_str))
    }

    /// Consumes the [`DeterministicCsrng`], returning the
    /// [`Mutex`](std::sync::Mutex)`<`[`Csprng`]`>`.
    pub fn into_inner_mutex(self) -> Mutex<Csprng> {
        self.0
    }

    fn borrow_csprng(&self) -> MutexGuard<'_, Csprng> {
        // Unwrap() is justified here because the MutexGuard is never externally exposed,
        // and none of the implementation is believed to panic.
        #[allow(clippy::unwrap_used)]
        self.0.lock().unwrap()
    }
}

impl Csrng for DeterministicCsrng {
    fn fill_buf(&self, buf: &mut [u8]) {
        self.borrow_csprng().fill_buf(buf);
    }

    fn next_bool(&self) -> bool {
        self.borrow_csprng().next_bool()
    }

    fn next_u8(&self) -> u8 {
        self.borrow_csprng().next_u8()
    }

    fn next_u32(&self) -> u32 {
        self.borrow_csprng().next_u32()
    }

    fn next_u64(&self) -> u64 {
        self.borrow_csprng().next_u64()
    }

    fn next_u128(&self) -> u128 {
        self.borrow_csprng().next_u128()
    }

    fn next_biguint(&self, bits: NonZeroUsize) -> BigUint {
        self.borrow_csprng().next_biguint(bits)
    }

    fn next_biguint_requiring_bits(&self, bits: NonZeroUsize) -> BigUint {
        self.borrow_csprng().next_biguint_requiring_bits(bits)
    }

    fn next_biguint_lt(&self, end: &BigUint) -> Option<BigUint> {
        self.borrow_csprng().next_biguint_lt(end)
    }

    fn next_biguint_range(&self, start: &BigUint, end: &BigUint) -> Option<BigUint> {
        self.borrow_csprng().next_biguint_range(start, end)
    }

    fn next_u32_range(&self, start: u32, end: u32) -> Option<u32> {
        let distr = Uniform::new(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_u32_rangeinclusive(&self, start: u32, end: u32) -> Option<u32> {
        let distr = Uniform::new_inclusive(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_usize_range(&self, start: usize, end: usize) -> Option<usize> {
        let distr = Uniform::new(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_usize_rangeinclusive(&self, start: usize, end: usize) -> Option<usize> {
        let distr = Uniform::new_inclusive(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_u64_range(&self, start: u64, end: u64) -> Option<u64> {
        let distr = Uniform::new(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }

    fn next_u64_rangeinclusive(&self, start: u64, end: u64) -> Option<u64> {
        let distr = Uniform::new_inclusive(start, end).ok()?;
        let csprng: &mut Csprng = &mut self.borrow_csprng();
        Some(distr.sample(csprng))
    }
}

impl Clone for DeterministicCsrng {
    /// Returns a copy of the [`DeterministicCsrng`].
    #[inline]
    fn clone(&self) -> Self {
        let csprng = self.borrow_csprng().next_csprng();
        Self::new(csprng)
    }
}

impl std::fmt::Display for DeterministicCsrng {
    /// Format the value suitable for user-facing output.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str("DeterministicCsrng")
    }
}

impl std::fmt::Debug for DeterministicCsrng {
    /// Format the value suitable for debugging output.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self, f)
    }
}

impl serde::Serialize for DeterministicCsrng {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        "DeterministicCsrng".serialize(serializer)
    }
}

assert_impl_all!(DeterministicCsrng: Send, Sync);

//=================================================================================================|
